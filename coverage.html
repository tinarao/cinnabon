
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cinnabon/cmd/main.go (0.0%)</option>
				
				<option value="file1">cinnabon/config/config.go (0.0%)</option>
				
				<option value="file2">cinnabon/internal/auth/auth.go (74.7%)</option>
				
				<option value="file3">cinnabon/internal/server/server.go (0.0%)</option>
				
				<option value="file4">cinnabon/internal/sessions/sessions.go (0.0%)</option>
				
				<option value="file5">cinnabon/internal/storage/db.go (50.0%)</option>
				
				<option value="file6">cinnabon/internal/storage/query.sql.go (68.8%)</option>
				
				<option value="file7">cinnabon/internal/storage/storage.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "cinnabon/config"
        "cinnabon/internal/server"
        "cinnabon/internal/storage"
        "log/slog"
        "os"
)

func main() <span class="cov0" title="0">{
        c := config.New("Secret", ":8080")
        c.Load()

        if err := storage.Init(); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to initialize storage", "error", err.Error())
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">defer storage.Conn.Close()

        server := server.New(c.Port)
        server.Start()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import "github.com/joho/godotenv"

type Config struct {
        Secret string
        Port   string // Default value is ":8080"
}

// New returns the new Config instance.
func New(secret string, port string) *Config <span class="cov0" title="0">{
        c := &amp;Config{
                Secret: secret,
                Port:   port,
        }

        return c
}</span>

func (c *Config) Load() error <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "cinnabon/internal/sessions"
        "cinnabon/internal/storage"
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "net/http"
        "strings"

        "github.com/go-playground/validator/v10"
        "golang.org/x/crypto/bcrypt"
)

var validate = validator.New()

type RegisterRequest struct {
        Email     string  `json:"email" validate:"required,email"`
        Username  *string `json:"username,omitempty" validate:"omitempty,min=3,max=32,alphanum"`
        FirstName *string `json:"first_name,omitempty" validate:"omitempty,min=2,max=50,alpha"`
        LastName  *string `json:"last_name,omitempty" validate:"omitempty,min=2,max=50,alpha"`
        Password  string  `json:"password" validate:"required,min=8,max=72"`
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type AuthResponse struct {
        Hash   string `json:"hash"`
        UserID int64  `json:"user_id"`
}

type ErrorResponse struct {
        Error string `json:"error"`
}

const SESSION_COOKIE_NAME = "session"
const SESSION_COOKIE_PATH = "/"
const SESSION_AUTH_HEADER = "Authorization"

func Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := validate.Struct(req); err != nil </span><span class="cov8" title="1">{
                sendError(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">_, err := storage.Q.GetUserByEmail(context.Background(), req.Email)
        if err == nil </span><span class="cov0" title="0">{
                sendError(w, "Email already exists", http.StatusConflict)
                return
        }</span>

        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                sendError(w, "Failed to process password", http.StatusInternalServerError)
                return
        }</span>

        // Convert optional fields to sql.NullString
        <span class="cov8" title="1">var username sql.NullString
        if req.Username != nil </span><span class="cov8" title="1">{
                username = sql.NullString{
                        String: *req.Username,
                        Valid:  true,
                }
        }</span>

        <span class="cov8" title="1">var firstName sql.NullString
        if req.FirstName != nil </span><span class="cov8" title="1">{
                firstName = sql.NullString{
                        String: *req.FirstName,
                        Valid:  true,
                }
        }</span>

        <span class="cov8" title="1">var lastName sql.NullString
        if req.LastName != nil </span><span class="cov8" title="1">{
                lastName = sql.NullString{
                        String: *req.LastName,
                        Valid:  true,
                }
        }</span>

        <span class="cov8" title="1">userID, err := storage.Q.CreateUser(context.Background(), storage.CreateUserParams{
                Email:     req.Email,
                Username:  username,
                FirstName: firstName,
                LastName:  lastName,
                Password:  string(hashedPassword),
        })
        if err != nil </span><span class="cov0" title="0">{
                sendError(w, "Failed to create user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">hash, err := sessions.New(userID)
        if err != nil </span><span class="cov0" title="0">{
                sendError(w, "Failed to create session", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     SESSION_COOKIE_NAME,
                Value:    hash,
                Path:     SESSION_COOKIE_PATH,
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteLaxMode,
        })

        sendJSON(w, AuthResponse{
                UserID: userID,
                Hash:   hash,
        }, http.StatusCreated)</span>
}

func Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                sendError(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">user, err := storage.Q.GetUserByEmail(context.Background(), req.Email)
        if err != nil </span><span class="cov8" title="1">{
                sendError(w, "Invalid credentials", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil </span><span class="cov8" title="1">{
                sendError(w, "Invalid credentials", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">hash, err := sessions.New(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                sendError(w, "Failed to create session", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">sendJSON(w, AuthResponse{
                UserID: user.ID,
                Hash:   hash,
        }, http.StatusOK)</span>
}

func Logout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        sessionID, err := getSessionIdFromHeader(r)
        if err != nil </span><span class="cov0" title="0">{
                sendError(w, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">_, err = sessions.GetUserBySessionHash(sessionID)
        if err != nil </span><span class="cov8" title="1">{
                sendError(w, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">err = storage.Q.DeleteSessionByHash(context.Background(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                sendError(w, "Failed to delete session", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

func sendError(w http.ResponseWriter, message string, status int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(ErrorResponse{Error: message})
}</span>

func sendJSON(w http.ResponseWriter, data interface{}, status int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

func getSessionIdFromHeader(r *http.Request) (string, error) <span class="cov8" title="1">{
        header := r.Header.Get(SESSION_AUTH_HEADER)
        if header == "" </span><span class="cov0" title="0">{
                return "", errors.New("session ID is required")
        }</span>

        <span class="cov8" title="1">parts := strings.Split(header, " ")
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                return "", errors.New("invalid session ID format")
        }</span>

        <span class="cov8" title="1">return parts[1], nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package server

import (
        "cinnabon/internal/auth"
        "log/slog"
        "net/http"

        "github.com/gorilla/mux"
)

type Server struct {
        Port string
}

func New(port string) *Server <span class="cov0" title="0">{
        return &amp;Server{
                Port: port,
        }
}</span>

func (s *Server) Start() <span class="cov0" title="0">{
        router := mux.NewRouter()
        router.HandleFunc("/healthcheck", s.healthcheck).Methods("GET")

        apiRouter := router.PathPrefix("/api").Subrouter()
        apiRouter.HandleFunc("/register", auth.Register).Methods("POST")
        apiRouter.HandleFunc("/login", auth.Login).Methods("POST")
        apiRouter.HandleFunc("/logout", auth.Logout).Methods("POST")

        if err := http.ListenAndServe(s.Port, router); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to start server", "error", err.Error())
        }</span>
}

func (s *Server) healthcheck(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package sessions

import (
        "cinnabon/internal/storage"
        "context"
        "errors"
        "log/slog"
        "time"

        "github.com/google/uuid"
)

const MAX_AGE = time.Hour * 24 * 30 // 30 days

func generateSessionID() string <span class="cov0" title="0">{
        uuid := uuid.New()
        return uuid.String()
}</span>

func New(userID int64) (hash string, err error) <span class="cov0" title="0">{
        h := generateSessionID()
        _, e := storage.Q.CreateSession(context.Background(), storage.CreateSessionParams{
                UserID:    userID,
                ExpiresAt: time.Now().Add(MAX_AGE),
                Hash:      h,
        })
        if e != nil </span><span class="cov0" title="0">{
                slog.Error("failed to create session", "error", e)
                return "", errors.New("failed to create session")
        }</span>

        <span class="cov0" title="0">return h, nil</span>
}

func GetSessionByHash(hash string) (userID int64, err error) <span class="cov0" title="0">{
        session, err := storage.Q.GetSessionByHash(context.Background(), hash)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("failed to get session")
        }</span>

        <span class="cov0" title="0">return session.UserID, nil</span>
}

func GetUserBySessionHash(hash string) (userID int64, err error) <span class="cov0" title="0">{
        userID, err = GetSessionByHash(hash)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("failed to get user by session hash")
        }</span>

        <span class="cov0" title="0">user, err := storage.Q.GetUserByID(context.Background(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("failed to get user by session hash")
        }</span>

        <span class="cov0" title="0">return user.ID, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package storage

import (
        "context"
        "database/sql"
)

type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package storage

import (
        "context"
        "database/sql"
        "time"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, hash, expires_at)
VALUES (?, ?, ?)
RETURNING hash
`

type CreateSessionParams struct {
        UserID    int64     `json:"user_id"`
        Hash      string    `json:"hash"`
        ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (string, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.Hash, arg.ExpiresAt)
        var hash string
        err := row.Scan(&amp;hash)
        return hash, err
}</span>

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, username, first_name, last_name, password, foreign_id)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id
`

type CreateUserParams struct {
        Email     string         `json:"email"`
        Username  sql.NullString `json:"username"`
        FirstName sql.NullString `json:"first_name"`
        LastName  sql.NullString `json:"last_name"`
        Password  string         `json:"password"`
        ForeignID sql.NullString `json:"foreign_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, createUser,
                arg.Email,
                arg.Username,
                arg.FirstName,
                arg.LastName,
                arg.Password,
                arg.ForeignID,
        )
        var id int64
        err := row.Scan(&amp;id)
        return id, err
}</span>

const deleteSessionByHash = `-- name: DeleteSessionByHash :exec
DELETE FROM sessions WHERE hash = ?
`

func (q *Queries) DeleteSessionByHash(ctx context.Context, hash string) error <span class="cov8" title="1">{
        _, err := q.db.ExecContext(ctx, deleteSessionByHash, hash)
        return err
}</span>

const deleteSessionById = `-- name: DeleteSessionById :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSessionById(ctx context.Context, id int64) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteSessionById, id)
        return err
}</span>

const getSessionByHash = `-- name: GetSessionByHash :one
SELECT id, hash, user_id, created_at, expires_at FROM sessions WHERE hash = ?
`

func (q *Queries) GetSessionByHash(ctx context.Context, hash string) (Session, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, getSessionByHash, hash)
        var i Session
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Hash,
                &amp;i.UserID,
                &amp;i.CreatedAt,
                &amp;i.ExpiresAt,
        )
        return i, err
}</span>

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, hash, user_id, created_at, expires_at FROM sessions WHERE id = ?
`

func (q *Queries) GetSessionByID(ctx context.Context, id int64) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getSessionByID, id)
        var i Session
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Hash,
                &amp;i.UserID,
                &amp;i.CreatedAt,
                &amp;i.ExpiresAt,
        )
        return i, err
}</span>

const getSessionByUserID = `-- name: GetSessionByUserID :one
SELECT id, hash, user_id, created_at, expires_at FROM sessions WHERE user_id = ?
`

func (q *Queries) GetSessionByUserID(ctx context.Context, userID int64) (Session, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getSessionByUserID, userID)
        var i Session
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Hash,
                &amp;i.UserID,
                &amp;i.CreatedAt,
                &amp;i.ExpiresAt,
        )
        return i, err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, foreign_id, first_name, last_name, password, created_at, updated_at FROM users WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.ForeignID,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Password,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, username, foreign_id, first_name, last_name, password, created_at, updated_at FROM users WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, getUserByID, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.Username,
                &amp;i.ForeignID,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Password,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package storage

import (
        "context"
        "database/sql"
        _ "embed"
        "os"

        _ "modernc.org/sqlite"
)

//go:embed schema.sql
var ddl string

var Conn *sql.DB
var Q *Queries

func Init() error <span class="cov0" title="0">{
        ctx := context.Background()
        var err error
        Conn, err = sql.Open("sqlite", "./db.sqlite")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := Conn.ExecContext(ctx, ddl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">Q = New(Conn)
        return nil</span>
}

func SetupTestDB() <span class="cov8" title="1">{
        dbFile := "test.db"
        os.Remove(dbFile)

        conn, err := sql.Open("sqlite", dbFile)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">_, err = conn.ExecContext(context.Background(), ddl)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">Conn = conn
        Q = New(conn)</span>
}

func TeardownTestDB() <span class="cov8" title="1">{
        if Conn != nil </span><span class="cov8" title="1">{
                Conn.Close()
        }</span>
        <span class="cov8" title="1">os.Remove("test.db")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
